---
title: "dataset1_logratio"
format: html
editor: visual
---

```{r}
# Setup
library(GEOquery)
library(limma)
library(WGCNA)
library(iCheck)
library(nlme)
library(dplyr)

options(stringsAsFactors = FALSE)
disableWGCNAThreads()

# Load data
gse   <- getGEO("GSE45238", GSEMatrix = TRUE)
eset  <- gse[[1]]

expr  <- exprs(eset)
pheno <- pData(eset)
annot <- fData(eset)

rownames(pheno) <- pheno$geo_accession
dim(expr); head(pheno); head(annot)

# Probe filtering
colnames(annot)
unique(annot$miRNA_version)

is_mature_v12 <- annot$TargetMatureVersion == 12
is_control <- grepl("control|spike|U6|snoR", annot$SYMBOL, ignore.case = TRUE)

keep_probes <- is_mature_v12 & !is_control
expr  <- expr[keep_probes, ]
annot <- annot[keep_probes, ]

dim(expr)
head(annot)

# Normalization
expr_log2 <- log2(expr + 1)
expr_norm <- normalizeBetweenArrays(expr_log2, method = "quantile")
rownames(expr_norm) <- rownames(expr)
colnames(expr_norm) <- colnames(expr)

# QC: PCA & sample clustering
op <- par(mar = c(5, 4, 4, 10), xpd = TRUE)

expr_t <- t(expr_norm)
pca <- prcomp(expr_t, scale. = TRUE)

sample_ids    <- colnames(expr_norm)
highlight_ids <- c("GSM1099641", "GSM1099655")
point_col     <- ifelse(sample_ids %in% highlight_ids, "red", "black")

plot(pca$x[,1], pca$x[,2],
     xlab = "PC1", ylab = "PC2",
     pch = 19,
     col = point_col,
     main = "PCA after normalization")

text(pca$x[,1], pca$x[,2],
     labels = sample_ids,
     pos = 3, cex = 0.6,
     col = point_col)

legend("topright",
       inset = c(-0.55, 0),
       legend = c("Other samples", "Outliers (to remove)"),
       col    = c("black", "red"),
       pch    = 19,
       bty    = "n")

par(op)

sampleTree <- hclust(dist(expr_t), method = "average")
plot(sampleTree, labels = colnames(expr_norm), cex = 0.6,
     main = "Sample clustering")
abline(h = 35, col = "red")

pdf("SampleClustering.pdf", width = 14, height = 10)
plot(sampleTree,
     labels = colnames(expr_norm),
     cex = 0.6,
     main = "Sample clustering dendrogram")
abline(h = 35, col = "red")
dev.off()

# Create patient IDs & remove outlier pairs
pheno$patient_id <- sub(".*_(\\d+)[NT]$", "\\1", pheno$title)
pheno$patient_id <- as.character(pheno$patient_id)

outlier_samples <- c("GSM1099641", "GSM1099655")

outlier_patient_ids <- unique(pheno$patient_id[
  pheno$geo_accession %in% outlier_samples
])

keep_samples <- !pheno$patient_id %in% outlier_patient_ids
expr_norm <- expr_norm[, keep_samples]
pheno     <- pheno[keep_samples, ]

dim(expr_norm)
table(pheno$patient_id)

```

```{r}
# Build tumor - normal Δ-expression
pheno$condition <- ifelse(grepl("T$", pheno$title), "tumor", "normal")
table(pheno$patient_id, pheno$condition)

patient_ids <- sort(unique(pheno$patient_id))

expr_delta <- sapply(patient_ids, function(pid) {
  normal_sample <- rownames(pheno)[pheno$patient_id == pid & pheno$condition == "normal"]
  tumor_sample  <- rownames(pheno)[pheno$patient_id == pid & pheno$condition == "tumor"]

  if (length(normal_sample) != 1 || length(tumor_sample) != 1) {
    stop("Patient ", pid, " does not have exactly one normal and one tumor sample.")
  }

  expr_norm[, tumor_sample] - expr_norm[, normal_sample]
})

expr_delta <- as.matrix(expr_delta)
colnames(expr_delta) <- patient_ids
dim(expr_delta)
head(expr_delta[, 1:5])

# Prepare data for WGCNA
datExpr <- t(expr_delta)
dim(datExpr)

gsg <- goodSamplesGenes(datExpr, verbose = 3)
gsg$allOK

```

```{r}
# Soft-threshold power selection
powers <- 1:20
sft <- pickSoftThreshold(datExpr,
                         powerVector = powers,
                         networkType = "signed",
                         verbose = 5)

par(mfrow = c(1,2))
plot(sft$fitIndices[,1],
     -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     type = "n",
     main = "Scale independence")
text(sft$fitIndices[,1],
     -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     labels = powers, cex = 0.8, col = "red")
abline(h = 0.80, col = "red")

plot(sft$fitIndices[,1],
     sft$fitIndices[,5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = "Mean connectivity")
text(sft$fitIndices[,1],
     sft$fitIndices[,5],
     labels = powers, cex = 0.8, col = "red")

```

```{r}
# Network construction + module detection
softPower <- 5
softPower

adjacency <- adjacency(datExpr, power = softPower, type = "signed")
TOM     <- TOMsimilarity(adjacency, TOMType = "signed")
dissTOM <- 1 - TOM

geneTree <- hclust(as.dist(dissTOM), method = "average")
plot(geneTree,
     main = "Clustering of miRNAs based on TOM",
     xlab = "", sub = "", cex = 0.4)

minModuleSize <- 30
dynamicMods <- cutreeDynamic(
  dendro = geneTree,
  distM = dissTOM,
  deepSplit = 2,
  pamRespectsDendro = FALSE,
  minClusterSize = minModuleSize
)

dynamicColors <- labels2colors(dynamicMods)
table(dynamicColors)

plotDendroAndColors(
  geneTree,
  dynamicColors,
  "Dynamic Tree Cut",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05,
  main = "miRNA dendrogram and module colors"
)

moduleColors0 <- dynamicColors
MElist <- moduleEigengenes(datExpr, colors = moduleColors0)
MEs    <- orderMEs(MElist$eigengenes)

mergeCutHeight <- 0.25
MEDiss <- 1 - cor(MEs)
METree <- stats::hclust(as.dist(MEDiss), method = "average")

dend <- as.dendrogram(METree)
plot(dend, main = "Clustering of module eigengenes (before merging)")
abline(h = mergeCutHeight, col = "red")

merge <- mergeCloseModules(
  datExpr,
  moduleColors0,
  cutHeight = mergeCutHeight,
  verbose = 3
)

moduleColors <- merge$colors
MEs          <- orderMEs(merge$newMEs)

dim(MEs)
head(MEs)

plotDendroAndColors(
  geneTree,
  cbind(moduleColors0, moduleColors),
  c("Dynamic Tree Cut", "Merged modules"),
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05,
  main = "Modules before and after merging"
)

```

```{r}
# Traits (per patient)
pheno_patient <- pheno[pheno$condition == "normal", ]
rownames(pheno_patient) <- pheno_patient$patient_id

patient_ids <- rownames(datExpr)
traits <- pheno_patient[patient_ids, c("age:ch1", "gender:ch1", "Stage:ch1")]
colnames(traits) <- c("Age", "Gender", "Stage")

traits$Age <- as.numeric(traits$Age)
traits$Gender <- ifelse(traits$Gender == "male", 1,
                        ifelse(traits$Gender == "female", 0, NA))
traits$Stage <- as.numeric(factor(traits$Stage, levels = c("I","II","III","IVA")))

head(traits)
identical(rownames(MEs), rownames(traits))

# Module–trait correlations
moduleTraitCor    <- cor(MEs, traits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nrow(datExpr))

moduleTraitCor
moduleTraitPvalue

labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = colnames(traits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colors = blueWhiteRed(50),
               textMatrix = signif(moduleTraitCor, 2),
               main = "Module–trait relationships")

```

```{r}
# Module-level Δ association (one-sample t-test vs 0)
names(moduleColors) <- colnames(datExpr)
mods <- sort(unique(moduleColors))

moduleDelta <- sapply(mods, function(mod) {
  genes <- names(moduleColors)[moduleColors == mod]
  rowMeans(datExpr[, genes, drop = FALSE], na.rm = TRUE)
})
moduleDelta <- as.matrix(moduleDelta)

tt <- apply(moduleDelta, 2, function(x) {
  x <- x[is.finite(x)]
  out <- t.test(x, mu = 0)
  c(n = length(x),
    mean = mean(x),
    t = unname(out$statistic),
    p = unname(out$p.value))
})

tt <- as.data.frame(t(tt))
tt$FDR <- p.adjust(tt$p, method = "BH")

module_tumor_assoc <- data.frame(Module = rownames(tt), tt, row.names = NULL)
module_tumor_assoc$n <- as.integer(module_tumor_assoc$n)
module_tumor_assoc <- module_tumor_assoc[order(module_tumor_assoc$FDR), ]
module_tumor_assoc

module_tumor_assoc_rounded <- module_tumor_assoc |>
  dplyr::mutate(
    mean = round(mean, 3),
    t    = round(t, 3),
    p    = signif(p, 3),
    FDR  = signif(FDR, 3)
  )
module_tumor_assoc_rounded
```

```{r}
# Hub miRNAs
IMConn  <- intramodularConnectivity(adjacency, moduleColors)
kWithin <- IMConn$kWithin

geneModuleMembership <- as.data.frame(cor(datExpr, MEs, use = "p"))
colnames(geneModuleMembership) <- paste0("MM", colnames(MEs))
rownames(geneModuleMembership) <- colnames(datExpr)

MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples = nrow(datExpr)))
colnames(MMPvalue) <- paste0("p.MM", colnames(MEs))
rownames(MMPvalue) <- colnames(datExpr)

geneSignificance <- as.data.frame(cor(datExpr, traits$Stage, use = "p"))
colnames(geneSignificance) <- "GSStages"
rownames(geneSignificance) <- colnames(datExpr)

GSPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneSignificance), nSamples = nrow(datExpr)))
colnames(GSPvalue) <- "p.GSStages"
rownames(GSPvalue) <- colnames(datExpr)

hubData <- data.frame(
  miRNA  = colnames(datExpr),
  module = moduleColors,
  kWithin = kWithin,
  geneModuleMembership,
  MMPvalue,
  geneSignificance,
  GSPvalue,
  row.names = NULL
)

hubList <- lapply(sort(unique(moduleColors)), function(mod) {
  hubData %>%
    dplyr::filter(module == mod) %>%
    dplyr::arrange(dplyr::desc(kWithin)) %>%
    head(10)
})
names(hubList) <- sort(unique(moduleColors))
hubList
```

```{r}
# Export module miRNA lists
moduleGenes <- split(colnames(datExpr), moduleColors)
for (mod in names(moduleGenes)) {
  write.table(moduleGenes[[mod]],
              file = paste0("module_", mod, "_miRNAs.txt"),
              row.names = FALSE,
              col.names = FALSE,
              quote = FALSE)
}

table(moduleColors)

# Per-miRNA Δ significance (one-sample t-test vs 0)
GS_meanDelta <- colMeans(datExpr, na.rm = TRUE)

tt_out <- apply(datExpr, 2, function(x) {
  x <- x[!is.na(x)]
  if (length(x) < 2) {
    return(c(n = length(x), mean = mean(x), t = NA_real_, p = NA_real_))
  }
  out <- t.test(x, mu = 0)
  c(n = length(x),
    mean = unname(out$estimate),
    t = unname(out$statistic),
    p = unname(out$p.value))
})

tt_out <- as.data.frame(t(tt_out))
tt_out$FDR <- p.adjust(tt_out$p, method = "BH")

gene_tumor_GS <- data.frame(
  miRNA = colnames(datExpr),
  n = tt_out$n,
  MeanDelta = tt_out$mean,
  t = tt_out$t,
  p = tt_out$p,
  FDR = tt_out$FDR
)
gene_tumor_GS <- gene_tumor_GS[order(gene_tumor_GS$FDR), ]
head(gene_tumor_GS, 20)

gene_tumor_GS$GS_signed_t <- sign(gene_tumor_GS$MeanDelta) * abs(gene_tumor_GS$t)
```

```{r}
# Compare logFold-WGCNA (Δ) to paired WGCNA (Li)
suppressPackageStartupMessages({
  library(pheatmap)
  library(mclust)
})

paired <- readRDS("paired_wgcna_export.rds")

moduleColors_wgcna <- paired$moduleColors
TOM_wgcna          <- paired$TOM

moduleColors_logFold <- moduleColors
TOM_logFold          <- TOM

if (is.null(names(moduleColors_wgcna)) || all(is.na(names(moduleColors_wgcna)))) {
  names(moduleColors_wgcna) <- rownames(TOM_wgcna)
}
miRNA_ids_w <- names(moduleColors_wgcna)
dimnames(TOM_wgcna) <- list(miRNA_ids_w, miRNA_ids_w)

if (is.null(names(moduleColors_logFold)) || all(is.na(names(moduleColors_logFold)))) {
  names(moduleColors_logFold) <- colnames(datExpr)
}
miRNA_ids_l <- names(moduleColors_logFold)
dimnames(TOM_logFold) <- list(miRNA_ids_l, miRNA_ids_l)

common <- intersect(rownames(TOM_wgcna), rownames(TOM_logFold))
stopifnot(length(common) > 10)

mw <- moduleColors_wgcna[common]
ml <- moduleColors_logFold[common]

tab <- table(WGCNA = mw, logFold = ml)

w_sizes <- rowSums(tab)
l_sizes <- colSums(tab)

rownames(tab) <- paste0(rownames(tab), " (n=", w_sizes, ")")
colnames(tab) <- paste0(colnames(tab), " (n=", l_sizes, ")")

cell_text <- matrix(paste0(tab),
                    nrow = nrow(tab), ncol = ncol(tab),
                    dimnames = dimnames(tab))

pheatmap::pheatmap(
  tab,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  display_numbers = cell_text,
  number_color = "black",
  fontsize_number = 8,
  main = "Module overlap: paired WGCNA (Li) vs logFold-WGCNA (Δ)"
)

ari <- mclust::adjustedRandIndex(as.integer(factor(mw)),
                                 as.integer(factor(ml)))
cat("ARI (module assignment agreement) =", round(ari, 3), "\n\n")

top_wgcna_me  <- paired$lmm_results$module[order(paired$lmm_results$p_tumour)][1]
top_wgcna_mod <- sub("^ME", "", top_wgcna_me)

genes_w_top <- names(moduleColors_wgcna)[moduleColors_wgcna == top_wgcna_mod]
logFold_modules <- setdiff(unique(moduleColors_logFold), "grey")

jacc_by_mod <- sapply(logFold_modules, function(mod) {
  genes_l <- names(moduleColors_logFold)[moduleColors_logFold == mod]
  length(intersect(genes_w_top, genes_l)) / length(union(genes_w_top, genes_l))
})
jacc_by_mod <- sort(jacc_by_mod, decreasing = TRUE)

best_mod <- names(jacc_by_mod)[1]

cat("Li top tumour module:", top_wgcna_mod, "\n")
cat("Best-overlap logFold module:", best_mod, "\n")
cat("Jaccard(best) =", round(jacc_by_mod[1], 3), "\n\n")
print(head(jacc_by_mod, 10))

A1 <- TOM_wgcna[common, common]
A2 <- TOM_logFold[common, common]

v1 <- A1[upper.tri(A1)]
v2 <- A2[upper.tri(A2)]

test_edge <- cor.test(v1, v2, method = "spearman", exact = FALSE)
print(test_edge)

plot(v1, v2, pch = 20,
     xlab = "Paired WGCNA TOM edge weight (unsigned)",
     ylab = "logFold-WGCNA TOM edge weight (signed, Δ)",
     main = "Edge-weight agreement (TOM)")

cat("\nInterpretation note: Li uses an *unsigned* network (|cor|),",
    "while your logFold run uses *signed* adjacency/TOM.",
    "So perfect agreement is not expected, even if biology overlaps.\n\n")

k_wgcna   <- rowSums(A1) - diag(A1)
k_logFold <- rowSums(A2) - diag(A2)

test_hub <- cor.test(k_wgcna, k_logFold, method = "spearman", exact = FALSE)
print(test_hub)

topK <- c(25, 50, 75, 100)
for (K in topK) {
  hubs_w <- names(sort(k_wgcna,   decreasing = TRUE))[1:K]
  hubs_l <- names(sort(k_logFold, decreasing = TRUE))[1:K]
  n_ol <- length(intersect(hubs_w, hubs_l))
  cat("Top", K, ": overlap =", n_ol,
      " (", round(100 * n_ol / K, 1), "%)\n", sep = "")
}
```

```{r}
# Summarize module sizes
mod_sizes <- sort(table(moduleColors_logFold), decreasing = TRUE)

modules_df <- data.frame(
  Module  = names(mod_sizes),
  Number_of_Genes = as.integer(mod_sizes),
  Relative_Amount = round(100 * as.integer(mod_sizes) / length(moduleColors_logFold), 1),
  row.names = NULL
)
modules_df
```

```{r}
# Top hubs per module with GS/MM/kWithin
gs_mat <- t(vapply(seq_len(ncol(datExpr)), function(j) {
  x <- datExpr[, j]
  x <- x[is.finite(x)]
  if (length(x) < 2) return(c(n=length(x), mean=mean(x), t=NA_real_, p=NA_real_))

  out <- t.test(x, mu = 0)
  c(n    = length(x),
    mean = unname(out$estimate),
    t    = unname(out$statistic),
    p    = unname(out$p.value))
}, FUN.VALUE = c(n=0, mean=0, t=0, p=0)))

gs_df <- as.data.frame(gs_mat)
gs_df$FDR <- p.adjust(gs_df$p, method = "BH")
rownames(gs_df) <- colnames(datExpr)

names(moduleColors) <- colnames(datExpr)

if (is.null(names(kWithin))) names(kWithin) <- colnames(datExpr)
if (is.null(rownames(geneModuleMembership))) rownames(geneModuleMembership) <- colnames(datExpr)

miRNAs <- colnames(datExpr)

mm_col1 <- paste0("MM", "ME", moduleColors[miRNAs])
mm_col2 <- paste0("MM", moduleColors[miRNAs])

MM_inModule <- mapply(function(g, c1, c2) {
  if (c1 %in% colnames(geneModuleMembership)) return(geneModuleMembership[g, c1])
  if (c2 %in% colnames(geneModuleMembership)) return(geneModuleMembership[g, c2])
  NA_real_
}, g = miRNAs, c1 = mm_col1, c2 = mm_col2)

GS_MM_kWithin <- data.frame(
  miRNA = miRNAs,
  module = moduleColors[miRNAs],
  kWithin = as.numeric(kWithin[miRNAs]),
  MM_inModule = as.numeric(MM_inModule),
  GS_t = as.numeric(gs_df[miRNAs, "t"]),
  p = as.numeric(gs_df[miRNAs, "p"]),
  FDR = as.numeric(gs_df[miRNAs, "FDR"]),
  row.names = NULL
)

top5_per_module <- GS_MM_kWithin %>%
  group_by(module) %>%
  arrange(desc(kWithin), .by_group = TRUE) %>%
  slice_head(n = 5) %>%
  ungroup()

top5_per_module
```

```{r}
# kWithinNorm overlap comparison (paired vs logFold)
kWithin_normalised <- function(A, colors) {
  stopifnot(is.matrix(A), nrow(A) == ncol(A))
  stopifnot(!is.null(rownames(A)))
  stopifnot(!is.null(names(colors)))

  common_genes <- intersect(rownames(A), names(colors))
  A <- A[common_genes, common_genes, drop = FALSE]
  colors <- colors[common_genes]

  out_list <- lapply(split(names(colors), colors), function(genes) {
    m <- length(genes)
    if (m < 2) return(NULL)

    subA <- A[genes, genes, drop = FALSE]
    kWithin <- rowSums(subA, na.rm = TRUE) - diag(subA)
    kWithinNorm <- kWithin / (m - 1)

    data.frame(
      gene = genes,
      module = unique(colors[genes]),
      moduleSize = m,
      kWithin = as.numeric(kWithin),
      kWithinNorm = as.numeric(kWithinNorm),
      row.names = NULL
    )
  })

  bind_rows(out_list)
}

A_wgcna <- if (!is.null(paired$adjacency)) paired$adjacency else paired$TOM
A_logF  <- if (exists("adjacency")) adjacency else TOM

if (is.null(rownames(A_wgcna)) && !is.null(names(moduleColors_wgcna))) {
  dimnames(A_wgcna) <- list(names(moduleColors_wgcna), names(moduleColors_wgcna))
}
if (is.null(rownames(A_logF)) && !is.null(names(moduleColors_logFold))) {
  dimnames(A_logF) <- list(names(moduleColors_logFold), names(moduleColors_logFold))
}

common2 <- intersect(rownames(A_wgcna), rownames(A_logF))
stopifnot(length(common2) > 10)

A_w <- A_wgcna[common2, common2, drop = FALSE]
A_l <- A_logF[common2, common2, drop = FALSE]

col_w <- moduleColors_wgcna[common2]
col_l <- moduleColors_logFold[common2]

kw_w <- kWithin_normalised(A_w, col_w)
kw_l <- kWithin_normalised(A_l, col_l)

get_top <- function(df, K) {
  df %>%
    arrange(desc(kWithinNorm)) %>%
    slice_head(n = K) %>%
    pull(gene)
}

topK2 <- c(10, 25, 50, 100, 500)
for (K in topK2) {
  hubs_w <- get_top(kw_w, K)
  hubs_l <- get_top(kw_l, K)

  ov <- length(intersect(hubs_w, hubs_l))
  cat("Top", K, ": overlap =", ov,
      " (", round(100 * ov / K, 1), "%)\n", sep = "")
}

overlap_top25 <- intersect(get_top(kw_w, 25), get_top(kw_l, 25))
overlap_top25
```
