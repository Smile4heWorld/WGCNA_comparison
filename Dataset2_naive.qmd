---
title: "Dataset2_naive"
format: html
editor: visual
---

```{r}
# Setup
library(WGCNA)
library(dplyr)

options(stringsAsFactors = FALSE)
disableWGCNAThreads()
set.seed(1)

infile <- "GSE62043_clean_noOutliers_20251223.RData"
load(infile)

stopifnot(exists("expr_gene"), exists("sample_info"))
if (!exists("datExpr0")) datExpr0 <- t(expr_gene)

stopifnot(identical(rownames(datExpr0), rownames(sample_info)))

datExpr <- datExpr0
message("datExpr dims: ", paste(dim(datExpr), collapse = " x "))

gsg <- goodSamplesGenes(datExpr, verbose = 3)
stopifnot(isTRUE(gsg$allOK))
```

```{r}
# Soft-threshold (unsigned)
powers <- 1:20
sft <- pickSoftThreshold(datExpr, powerVector = powers, networkType = "unsigned", verbose = 5)

par(mfrow = c(1, 2))
plot(sft$fitIndices[, 1], -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     type = "n", main = "Scale independence")
text(sft$fitIndices[, 1], -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = 0.8, col = "red")
abline(h = 0.90, col = "red")

plot(sft$fitIndices[, 1], sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n", main = "Mean connectivity")
text(sft$fitIndices[, 1], sft$fitIndices[, 5], labels = powers, cex = 0.8, col = "red")

softPower <- if (!is.na(sft$powerEstimate)) sft$powerEstimate else {
  fit <- -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2]
  if (any(fit >= 0.90, na.rm = TRUE)) powers[which(fit >= 0.90)[1]] else 7
}
softPower <- 9
message("softPower = ", softPower)
```

```{r}
# blockwiseModules network
minModuleSize  <- 70
mergeCutHeight <- 0.25

datExpr_use <- datExpr
maxBlockSize <- min(12000, ncol(datExpr_use))

net <- blockwiseModules(
  datExpr_use,
  power              = softPower,
  networkType        = "unsigned",
  TOMType            = "unsigned",
  corType            = "pearson",
  maxBlockSize       = maxBlockSize,
  minModuleSize      = minModuleSize,
  reassignThreshold  = 0,
  mergeCutHeight     = mergeCutHeight,
  deepSplit          = 2,
  pamRespectsDendro  = FALSE,
  numericLabels      = FALSE,
  verbose            = 3
)

moduleColors <- net$colors
names(moduleColors) <- colnames(datExpr_use)
MEs <- orderMEs(net$MEs)

message("Module color counts:")
print(table(moduleColors))
```

```{r}
# Dendrogram + colors
nBlocks <- length(net$dendrograms)
par(mfrow = c(min(nBlocks, 2), ifelse(nBlocks > 1, 2, 1)))

for (b in seq_len(nBlocks)) {
  blockGenes  <- net$blockGenes[[b]]
  blockColors <- moduleColors[blockGenes]
  plotDendroAndColors(
    net$dendrograms[[b]],
    blockColors,
    groupLabels  = paste0("Block ", b),
    dendroLabels = FALSE,
    hang         = 0.03,
    addGuide     = TRUE,
    guideHang    = 0.05,
    main         = paste0("Gene dendrogram + modules (block ", b, ")")
  )
}
par(mfrow = c(1, 1))
```

```{r}
# Module–trait cor heatmap (naive)
tumour <- as.integer(sample_info$tumour)
moduleTraitCor <- cor(MEs, tumour, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nrow(datExpr_use))

ord <- order(moduleTraitPvalue[, 1], na.last = TRUE)
moduleTraitCor <- moduleTraitCor[ord, , drop = FALSE]
moduleTraitPvalue <- moduleTraitPvalue[ord, , drop = FALSE]

moduleLabels <- sub("^ME", "", rownames(moduleTraitCor))

textMatrix <- paste0(sprintf("%.2f", moduleTraitCor), "\n(", signif(moduleTraitPvalue, 2), ")")
dim(textMatrix) <- dim(moduleTraitCor)

nMod <- nrow(moduleTraitCor)
pdf("module_trait_heatmap.pdf", width = 7, height = max(5, 0.35 * nMod + 2))
par(mar = c(6, 9, 4, 2))

labeledHeatmap(
  Matrix        = moduleTraitCor,
  xLabels       = "Tumour",
  yLabels       = moduleLabels,
  ySymbols      = moduleLabels,
  colors        = blueWhiteRed(50),
  textMatrix    = textMatrix,
  setStdMargins = FALSE,
  cex.lab       = 1.2,
  cex.text      = 0.9,
  xLabelsAngle  = 45,
  main          = "Independent module–trait relationships\n(simple correlations)"
)
dev.off()
```

```{r}
# Gene significance (naive |cor|)
tumour_vec <- tumour
geneGS_vec <- as.vector(cor(datExpr_use, tumour_vec, use = "p"))
names(geneGS_vec) <- colnames(datExpr_use)

geneGS <- data.frame(
  gene = names(geneGS_vec),
  GS   = abs(geneGS_vec),
  row.names = names(geneGS_vec)
)
```

```{r}
# MM + kWithin + top hubs
modNames <- substring(colnames(MEs), 3)

geneModuleMembership <- as.data.frame(cor(datExpr_use, MEs, use = "p"))
colnames(geneModuleMembership) <- paste0("MM", modNames)
rownames(geneModuleMembership) <- colnames(datExpr_use)

compute_kWithin_by_module <- function(datExpr, colors, power, networkType = "unsigned", maxModuleSize = 5000) {
  genes <- colnames(datExpr)
  kWithin <- rep(NA_real_, length(genes))
  names(kWithin) <- genes

  mods <- unique(colors)
  for (mod in mods) {
    inMod <- which(colors == mod)
    if (length(inMod) < 2) next

    if (length(inMod) > maxModuleSize) {
      message("Module ", mod, " has n=", length(inMod), " genes; using softConnectivity proxy for kWithin.")
      kWithin[inMod] <- softConnectivity(datExpr[, inMod, drop = FALSE], power = power, type = networkType)
    } else {
      A <- adjacency(datExpr[, inMod, drop = FALSE], power = power, type = networkType)
      kWithin[inMod] <- rowSums(A) - 1
    }
  }

  data.frame(gene = genes, kWithin = kWithin, row.names = genes)
}

IMConn_df <- compute_kWithin_by_module(datExpr_use, moduleColors, power = softPower, networkType = "unsigned")

hubData <- data.frame(
  gene   = colnames(datExpr_use),
  module = moduleColors,
  geneModuleMembership,
  GS     = geneGS[colnames(datExpr_use), "GS"],
  row.names = NULL
) %>%
  left_join(IMConn_df[, c("gene", "kWithin")], by = "gene")

hubList <- hubData %>%
  group_by(module) %>%
  arrange(desc(kWithin)) %>%
  slice_head(n = 10) %>%
  ungroup()

print(hubList)
```

```{r}
# Example GS vs MM plot
targetModule <- "blue"
mm_col <- paste0("MM", targetModule)
inMod <- hubData$module == targetModule

if (any(inMod) && mm_col %in% names(hubData)) {
  plot(hubData[[mm_col]][inMod],
       hubData$GS[inMod],
       xlab = paste0("Module membership (", targetModule, ")"),
       ylab = "Gene significance for tumour (|cor|)",
       main = paste("GS vs MM in", targetModule, "module (independent)"))
  df <- hubData[inMod, c("GS", mm_col)]
  colnames(df)[2] <- "MM"
  abline(lm(GS ~ MM, data = df), lty = 2)
}
```

```{r}
# Exports (independent)
moduleGenes <- split(hubData$gene, hubData$module)

for (mod in names(moduleGenes)) {
  write.table(
    moduleGenes[[mod]],
    file = paste0("module_", mod, "_genes_independent_blockwise.txt"),
    row.names = FALSE, col.names = FALSE, quote = FALSE
  )
}

for (mod in unique(hubList$module)) {
  sub <- hubList[hubList$module == mod, ]
  write.table(
    sub,
    file = paste0("module_", mod, "_top10_hubs_independent_blockwise.txt"),
    row.names = FALSE, quote = FALSE, sep = "\t"
  )
}
```

```{r}
# Compare independent vs paired export
paired_file <- "paired_wgcna_export_GSE62043_20260102.rds"
paired <- readRDS(paired_file)

moduleColors_ind <- moduleColors
softPower_ind <- softPower

moduleColors_paired <- paired$moduleColors
softPower_paired <- paired$softPower
lmm_paired <- paired$lmm_results

if (is.null(names(moduleColors_ind))) names(moduleColors_ind) <- colnames(datExpr_use)
common_genes <- intersect(colnames(datExpr_use), names(moduleColors_paired))
stopifnot(length(common_genes) > 0)

mn <- moduleColors_ind[common_genes]
mp <- moduleColors_paired[common_genes]

tab <- table(Independent = mn, Paired = mp)

rn <- paste0(rownames(tab), " (n=", rowSums(tab), ")")
cn <- paste0(colnames(tab), " (n=", colSums(tab), ")")
dimnames(tab) <- list(rn, cn)

if (requireNamespace("pheatmap", quietly = TRUE)) {
  mat <- as.matrix(tab)
  pheatmap::pheatmap(
    mat,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    main = "Module overlap: Independent(blockwise) vs Paired WGCNA",
    display_numbers = mat,
    number_format = "%.0f",
    fontsize_number = 8
  )
} else {
  print(tab)
}

if (requireNamespace("mclust", quietly = TRUE)) {
  ari <- mclust::adjustedRandIndex(as.integer(factor(mn)), as.integer(factor(mp)))
  cat("ARI(independent blockwise vs paired) =", ari, "\n")
}

best_ind_ME <- rownames(moduleTraitPvalue)[which.min(moduleTraitPvalue)]
best_ind_mod <- sub("^ME", "", best_ind_ME)

if ("FDR_tumour" %in% names(lmm_paired)) {
  best_paired_ME <- lmm_paired$module[which.min(lmm_paired$FDR_tumour)]
} else if ("FDR" %in% names(lmm_paired)) {
  best_paired_ME <- lmm_paired$module[which.min(lmm_paired$FDR)]
} else {
  best_paired_ME <- lmm_paired$module[which.min(lmm_paired$p_tumour)]
}
best_paired_mod <- sub("^ME", "", best_paired_ME)

genes_ind_top <- intersect(names(moduleColors_ind)[moduleColors_ind == best_ind_mod], common_genes)
genes_paired_top <- intersect(names(moduleColors_paired)[moduleColors_paired == best_paired_mod], common_genes)

jaccard <- length(intersect(genes_ind_top, genes_paired_top)) / length(union(genes_ind_top, genes_paired_top))

cat("Top independent module :", best_ind_mod, " (", best_ind_ME, ")\n", sep = "")
cat("Top paired module      :", best_paired_mod, " (", best_paired_ME, ")\n", sep = "")
cat("Jaccard(top modules)   =", jaccard, "\n")

maxGenesCompare <- 3000
vars_common <- apply(datExpr_use[, common_genes, drop = FALSE], 2, var, na.rm = TRUE)
genes_comp <- names(sort(vars_common, decreasing = TRUE))[1:min(maxGenesCompare, length(vars_common))]

X <- datExpr_use[, genes_comp, drop = FALSE]

A_ind <- adjacency(X, power = softPower_ind, type = "unsigned")
T_ind <- TOMsimilarity(A_ind, TOMType = "unsigned")

A_p <- adjacency(X, power = softPower_paired, type = "unsigned")
T_p <- TOMsimilarity(A_p, TOMType = "unsigned")

dimnames(T_ind) <- list(colnames(X), colnames(X))
dimnames(T_p) <- list(colnames(X), colnames(X))

v1 <- T_ind[upper.tri(T_ind)]
v2 <- T_p[upper.tri(T_p)]

rho_edges <- suppressWarnings(cor(v1, v2, method = "spearman", use = "complete.obs"))
cat("Spearman rho (TOM edges) =", rho_edges, "\n")

set.seed(1)
maxEdgesTest <- 200000
idx <- if (length(v1) > maxEdgesTest) sample.int(length(v1), maxEdgesTest) else seq_along(v1)
print(cor.test(v1[idx], v2[idx], method = "spearman"))

maxPlot <- 50000
idxp <- if (length(v1) > maxPlot) sample.int(length(v1), maxPlot) else seq_along(v1)
plot(v1[idxp], v2[idxp], pch = 20,
     xlab = "Independent TOM edge weight",
     ylab = "Paired TOM edge weight",
     main = "Edge-weight agreement (TOM): independent(blockwise) vs paired")

kWithin_normalised <- function(A, colors, drop_grey = TRUE) {
  stopifnot(is.matrix(A), nrow(A) == ncol(A))
  stopifnot(!is.null(rownames(A)))
  stopifnot(!is.null(names(colors)))

  common_genes2 <- intersect(rownames(A), names(colors))
  A <- A[common_genes2, common_genes2, drop = FALSE]
  colors <- colors[common_genes2]

  if (drop_grey) {
    keep <- colors != "grey"
    A <- A[keep, keep, drop = FALSE]
    colors <- colors[keep]
  }

  out_list <- lapply(split(names(colors), colors), function(genes) {
    m <- length(genes)
    if (m < 2) return(NULL)

    subA <- A[genes, genes, drop = FALSE]
    kWithin <- rowSums(subA, na.rm = TRUE) - diag(subA)
    kWithinNorm <- kWithin / (m - 1)

    data.frame(
      gene = genes,
      module = unique(colors[genes]),
      moduleSize = m,
      kWithin = as.numeric(kWithin),
      kWithinNorm = as.numeric(kWithinNorm),
      row.names = NULL
    )
  })

  dplyr::bind_rows(out_list)
}

col_ind_sub <- moduleColors_ind[colnames(X)]
col_p_sub <- moduleColors_paired[colnames(X)]
names(col_ind_sub) <- colnames(X)
names(col_p_sub) <- colnames(X)

kw_ind <- kWithin_normalised(T_ind, col_ind_sub, drop_grey = FALSE)
kw_p <- kWithin_normalised(T_p, col_p_sub, drop_grey = FALSE)

kw_m <- merge(
  kw_ind[, c("gene", "kWithinNorm")],
  kw_p[, c("gene", "kWithinNorm")],
  by = "gene",
  suffixes = c("_ind", "_paired")
)

rho_kw <- suppressWarnings(cor(kw_m$kWithinNorm_ind, kw_m$kWithinNorm_paired,
                               method = "spearman", use = "complete.obs"))
cat("Spearman rho (kWithinNorm) =", rho_kw, "\n")
print(cor.test(kw_m$kWithinNorm_ind, kw_m$kWithinNorm_paired, method = "spearman"))

get_top <- function(df, K) df %>% dplyr::arrange(dplyr::desc(kWithinNorm)) %>% dplyr::slice_head(n = K) %>% dplyr::pull(gene)

topK <- c(25, 100, 500, 2000)
for (K in topK) {
  K0 <- min(K, nrow(kw_m))
  hubs_ind <- get_top(kw_ind, K0)
  hubs_p <- get_top(kw_p, K0)
  n_overlap <- length(intersect(hubs_ind, hubs_p))
  cat("Top", K0, ": overlap =", n_overlap, " (", round(100 * n_overlap / K0, 1), "%)\n", sep = "")
}
```

```{r}
# Top-5 GS genes per module: naive vs paired
suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
})

modules_to_check <- c("green", "turquoise", "salmon")

tumour_vec <- as.integer(sample_info$tumour)
GS_naive <- abs(cor(datExpr_use, tumour_vec, use = "p"))
names(GS_naive) <- colnames(datExpr_use)

get_paired_GS <- function(paired, datExpr, sample_info) {
  if (!is.null(paired$geneGS)) {
    GS <- paired$geneGS
    if (is.data.frame(GS) && all(c("gene", "GS") %in% names(GS))) {
      v <- GS$GS; names(v) <- GS$gene; return(v)
    }
    if (is.numeric(GS) && !is.null(names(GS))) return(GS)
  }

  if (!is.null(paired$gene_results) && is.data.frame(paired$gene_results)) {
    gr <- paired$gene_results
    if (all(c("gene", "GS") %in% names(gr))) {
      v <- gr$GS; names(v) <- gr$gene; return(v)
    }
    if (all(c("gene", "t_tumour") %in% names(gr))) {
      v <- abs(gr$t_tumour); names(v) <- gr$gene; return(v)
    }
    if (all(c("gene", "beta_tumour") %in% names(gr))) {
      v <- abs(gr$beta_tumour); names(v) <- gr$gene; return(v)
    }
    if (all(c("gene", "p_tumour") %in% names(gr))) {
      v <- -log10(gr$p_tumour); names(v) <- gr$gene; return(v)
    }
  }

  id_candidates <- c("patient_id", "patient", "subject", "pair_id", "pair", "id")
  id_col <- id_candidates[id_candidates %in% names(sample_info)][1]
  if (is.na(id_col)) {
    stop("Couldn't find a patient/pair ID column in sample_info. Add one (e.g., sample_info$patient_id) or store geneGS in the paired export.")
  }

  pair_id <- sample_info[[id_col]]
  tumour <- as.integer(sample_info$tumour)

  idx_t <- which(tumour == 1)
  idx_n <- which(tumour == 0)

  map_t <- data.frame(pair_id = pair_id[idx_t], row_t = idx_t)
  map_n <- data.frame(pair_id = pair_id[idx_n], row_n = idx_n)

  m <- merge(map_t, map_n, by = "pair_id")
  if (nrow(m) < 3) stop("Too few complete pairs to compute paired GS reliably.")

  X_t <- datExpr[m$row_t, , drop = FALSE]
  X_n <- datExpr[m$row_n, , drop = FALSE]
  D <- X_t - X_n

  nP <- nrow(D)
  mu <- colMeans(D, na.rm = TRUE)
  sdv <- apply(D, 2, sd, na.rm = TRUE)
  tstat <- mu / (sdv / sqrt(nP))

  GS <- abs(tstat)
  names(GS) <- colnames(datExpr)
  GS
}

GS_paired <- get_paired_GS(paired, datExpr_use, sample_info)

top_genes_by_module <- function(GS, moduleColors, modules, top_n = 5) {
  stopifnot(!is.null(names(GS)))
  stopifnot(!is.null(names(moduleColors)))

  common <- intersect(names(GS), names(moduleColors))
  GS <- GS[common]
  moduleColors <- moduleColors[common]

  dplyr::bind_rows(lapply(modules, function(mod) {
    genes <- names(moduleColors)[moduleColors == mod]
    genes <- intersect(genes, names(GS))
    if (length(genes) == 0) {
      return(dplyr::tibble(module = mod, rank = integer(), gene = character(), GS = numeric()))
    }

    dplyr::tibble(gene = genes, GS = as.numeric(GS[genes])) %>%
      dplyr::arrange(dplyr::desc(GS)) %>%
      dplyr::slice_head(n = top_n) %>%
      dplyr::mutate(module = mod, rank = dplyr::row_number()) %>%
      dplyr::select(module, rank, gene, GS)
  }))
}

stopifnot(!is.null(names(moduleColors_ind)), !is.null(names(moduleColors_paired)))

top_naive <- top_genes_by_module(GS_naive, moduleColors_ind, modules_to_check, top_n = 5) %>%
  mutate(method = "naive")
top_paired <- top_genes_by_module(GS_paired, moduleColors_paired, modules_to_check, top_n = 5) %>%
  mutate(method = "paired")

for (mod in modules_to_check) {
  cat("\n====================\nModule:", mod, "\n")

  tn <- top_naive %>% filter(module == mod) %>% arrange(rank)
  tp <- top_paired %>% filter(module == mod) %>% arrange(rank)

  cat("\nTop 5 (naive GS):\n")
  print(tn)

  cat("\nTop 5 (paired GS):\n")
  print(tp)

  ov <- intersect(tn$gene, tp$gene)
  cat("\nOverlap (top5):", length(ov), "genes\n")
  if (length(ov)) cat("Overlapping genes:", paste(ov, collapse = ", "), "\n")
}

summary_table <- bind_rows(top_naive, top_paired) %>%
  mutate(GS = signif(GS, 4)) %>%
  arrange(module, method, rank) %>%
  pivot_wider(names_from = method, values_from = c(gene, GS), names_sep = "_")

print(summary_table)

write.table(summary_table, "top5_GS_by_module_naive_vs_paired.tsv",
            sep = "\t", quote = FALSE, row.names = FALSE)
```
